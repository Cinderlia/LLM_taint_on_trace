# joerntrace 使用说明（中文）

## 目录结构与输入文件

本项目默认以“当前工作目录”为基准，使用三类目录：

- `input/`：所有输入文件（默认 `./input`）
- `tmp/`：中间产物/缓存（默认 `./tmp`）
- `test/`：日志与调试输出（默认 `./test`）

上述目录可通过以下方式覆盖（任意一种即可）：

- `config.json`：配置 `paths.input_dir / paths.tmp_dir / paths.test_dir`（相对路径按当前工作目录解析）
- 命令行参数：`--config`、`--input-dir`、`--tmp-dir`、`--test-dir`
- 环境变量：`JOERNTRACE_CONFIG`（等价于 `--config`）

运行前通常需要准备这些输入文件（放在 `input/` 下）：

- `trace.log`：动态 trace，每行形如 `path:line | ...`，行号（从 1 开始）就是后续脚本里说的 `seq`。
- `nodes.csv`：CPG 节点表（含 `id:int`、`type`、`code`、`name`、`lineno:int`、`funcid:int` 等字段）。
- `rels.csv`：AST 关系表（主要用 `PARENT_OF`）。
- `cpg_edges.csv`：CPG 边表（需要 `CALLS` 边用于函数调用解析；如果没有也可以用 `trace_edges.csv` 兜底）。

可选/派生输入：

- `trace_edges.csv`：由 `trace_edges.py` 生成的补充 `CALLS` 边（当 `cpg_edges.csv` 缺失部分 `CALLS` 时使用）。
- `tmp/trace_index.json`：由 `analyze_if_line.py`/`branch_selector` 自动生成的 trace 索引缓存。

## 脚本说明

### 1) `analyze_if_line.py`

用途：给定一个 `seq`（`trace.log` 的行号），定位该行对应的 `if` 条件元素（`AST_IF_ELEM`）并做污点回溯/扩散；支持两种模式：

- 普通模式：基于 taint_handlers 里的规则做回溯（不调用 LLM）。
- LLM 模式：先用 handler 扩展出代码片段，再向 LLM 请求“影响者 taints + dataflow edges”，再把叶子节点扩散入队继续迭代。
- LLM 测试模式：只生成 prompt 并回放本地 response 文件（绝不调用 LLM），用于快速验证 prompt 生成与返回解析/映射逻辑。

用法：

- `python analyze_if_line.py <seq>`
- `python analyze_if_line.py <seq> --debug`
- `python analyze_if_line.py <seq> --llm`
- `python analyze_if_line.py <seq> --llm-test`
- `python analyze_if_line.py <seq> --llm-test --llm-max=<N>`
- `python analyze_if_line.py <seq> --llm --llm-max=<N>`
- `python analyze_if_line.py <seq> --llm --llm-max <N>`
- `python analyze_if_line.py <seq> --input-dir ./input --tmp-dir ./tmp --test-dir ./test`

参数：

- `<seq>`：`trace.log` 的行号，从 1 开始。
- `--debug`：将日志级别设为 DEBUG（输出文件不额外扩展字段）。
- `--llm`：启用 LLM 扩散模式（优先读取 `test/llm/responses/` 回放；若缺失则尝试调用已配置的 LLM；会写入 `test/llm/prompts/` 与 `test/llm/responses/`）。
- `--llm-test`：启用 LLM 测试模式（只回放本地 `test/llm/responses/`；缺失时用空返回继续流程，但不会调用 LLM）。
- `--llm-max` / `--llm-max=<N>`：限制最多调用 LLM 的次数（不传则不限制）。

输出：

- `test/seq_<seq>/analysis_output_<seq>.json`：主输出文件，字段包括：
  - `input_seq`：输入的 `seq`。
  - `initial_taints`：初始污点集。
  - `result_set`：最终结果集（每项含 `seq/path/line/loc`）。
- `test/seq_<seq>/logs/*.log`：运行日志；LLM 模式下会出现 `queue_diffusion`、`llm_call` 等事件。
- `test/seq_<seq>/llm/prompts/*.txt`、`test/seq_<seq>/llm/responses/*.txt`：LLM 调用输入/输出留档。

### 2) `trace_edges.py`

用途：根据 `trace.log` 相邻 trace 分组，推断缺失的 `CALLS` 边并输出到 `trace_edges.csv`，用于弥补 `cpg_edges.csv` 中缺失的调用边。

用法：

- `python trace_edges.py`
  - 可带路径参数：`python trace_edges.py --input-dir ./input --tmp-dir ./tmp --test-dir ./test`
- 等价实现（同样输出到 `tmp/trace_edges.csv`）：`python cpg_utils/trace_call_edges.py`

输出：

- `tmp/trace_edges.csv`：补充的 `CALLS` 边（TSV：`start end type var`）。
- `test/trace_edges/trace_debug.json`：调试信息（每个 trace group 的匹配情况、候选调用等）。
- `test/trace_edges/trace_stats.txt`：统计信息（groups、missing_edges、existing_edges_in_cpg_edges）。

### 3) `if_extract.py`

用途：从给定源码位置（`/app/...:line`）提取该行对应的 `AST_IF_ELEM` 及其相关变量/调用信息，生成可读文本输出，供人工检查或给 `taint_trace.py` 使用。

用法：

- `python if_extract.py /app/phpbb/memberlist.php:98`

输出：

- `test/if_extract/if_extract_output.txt`：文本输出（包含 input/if_elem_ids/变量/方法调用等）。

### 4) `taint_trace.py`

用途：离线（不依赖 LLM）地做一套基于 `trace_debug.json` + `if_extract_output.txt` 的 taint 扩散实验，输出每轮迭代的细节与最终污点集合。

用法：

- `python taint_trace.py`

前置条件：

- 先运行 `python trace_edges.py` 或 `python cpg_utils/trace_call_edges.py` 生成 `test/trace_edges/trace_debug.json`（以及 `tmp/trace_edges.csv`）。
- 先运行 `python if_extract.py <path:line>` 生成 `test/if_extract/if_extract_output.txt`。

输出：

- `test/taint_trace/taint_debug.json`：每轮迭代的扩散细节（A/B 交替、added_by_* 等）。
- `test/taint_trace/taint_result.txt`：最终污点集合（按 `id type name` 输出）。

### 5) `if_elem_types.py`

用途：扫描 `nodes.csv` 中所有 `AST_IF_ELEM` 的后代节点，统计可能出现的“变量/表达式类型”，用于观察数据集覆盖情况。

用法：

- `python if_elem_types.py`

输出：

- `if_elem_types.txt`：收集到的类型列表（每行一个）。

### 6) `branch_selector/pipeline.py`

用途：扫描 `trace.log` 前 N 行（可配置），筛出包含 `AST_IF/AST_SWITCH` 的 `seq`，拼接为分批 prompt 交给 LLM 做筛选；再把 LLM 选中的 `seq` 送入 `analyze_if_line.py` 做后续分析。支持测试模式（只输出 prompt 并模拟返回，不调用 LLM）。

用法：

- `python branch_selector/pipeline.py`
- `python branch_selector/pipeline.py <config_path>`（可选；默认读取根目录的 `config.json`）

配置：

- `config.json` 的 `branch_selector` 段：包含 `seq_limit`、`buffer_token_limit`、`buffer_count`、`max_analyze_concurrency`、`test_mode`、`base_prompt` 等字段（也支持把这些字段直接放在单独的配置文件里传给 pipeline）。

输出：

- `test/branch_selector/prompts/prompt_<id>.txt`：按缓冲区批次生成的 prompt。
- `test/branch_selector/responses/response_<id>.json`：测试模式下模拟的 LLM 返回。

## 常见输出文件速查

- `tmp/trace_index.json`：trace 索引缓存（将 `(path,line)` 映射到可能的 `seq/node_ids`）。
- `test/seq_<seq>/analysis_output_<seq>.json`：`analyze_if_line.py` 的主输出。
- `test/seq_<seq>/logs/*.log`：运行日志（INFO/DEBUG/WARNING/ERROR 分文件）。
- `test/seq_<seq>/llm/prompts/*.txt`、`test/seq_<seq>/llm/responses/*.txt`：LLM 调用输入/输出留档。
- `test/branch_selector/prompts/*.txt`、`test/branch_selector/responses/*.json`：分支筛选组件的 prompt 与模拟返回。
- `tmp/trace_edges.csv`：推断补充的 `CALLS` 边（可被 handler/LLM 筛选逻辑使用）。
- `test/trace_edges/trace_debug.json`：trace 分组与节点匹配调试信息（`taint_trace.py` 依赖）。
- `test/trace_edges/trace_stats.txt`：trace_edges 统计信息。
- `test/if_extract/if_extract_output.txt`：if_extract 文本输出（`taint_trace.py` 依赖）。
- `test/taint_trace/taint_debug.json`、`test/taint_trace/taint_result.txt`：taint_trace 输出。
