# joerntrace 使用说明（中文）

## 目录结构与输入文件

本项目默认在当前工作目录读取/写入数据文件。运行前通常需要准备这些输入文件：

- `trace.log`：动态 trace，每行形如 `path:line | ...`，行号（从 1 开始）就是后续脚本里说的 `seq`。
- `nodes.csv`：CPG 节点表（含 `id:int`、`type`、`code`、`name`、`lineno:int`、`funcid:int` 等字段）。
- `rels.csv`：AST 关系表（主要用 `PARENT_OF`）。
- `cpg_edges.csv`：CPG 边表（需要 `CALLS` 边用于函数调用解析；如果没有也可以用 `trace_edges.csv` 兜底）。

可选/派生输入：

- `trace_edges.csv`：由 `trace_edges.py` 生成的补充 `CALLS` 边（当 `cpg_edges.csv` 缺失部分 `CALLS` 时使用）。
- `test/trace_index.json`：由 `analyze_if_line.py` 自动生成的 trace 索引缓存。

## 脚本说明

### 1) `analyze_if_line.py`

用途：给定一个 `seq`（`trace.log` 的行号），定位该行对应的 `if` 条件元素（`AST_IF_ELEM`）并做污点回溯/扩散；支持两种模式：

- 普通模式：基于 taint_handlers 里的规则做回溯（不调用 LLM）。
- LLM 模式：先用 handler 扩展出代码片段，再向 LLM 请求“影响者 taints + dataflow edges”，再把叶子节点扩散入队继续迭代。

用法：

- `python analyze_if_line.py <seq>`
- `python analyze_if_line.py <seq> --debug`
- `python analyze_if_line.py <seq> --llm`
- `python analyze_if_line.py <seq> --llm --llm-max=<N>`
- `python analyze_if_line.py <seq> --llm --llm-max <N>`

参数：

- `<seq>`：`trace.log` 的行号，从 1 开始。
- `--debug`：将日志级别设为 DEBUG（输出文件不额外扩展字段）。
- `--llm`：启用 LLM 扩散模式（会写入 `test/llm/prompts/` 与 `test/llm/responses/`）。
- `--llm-max` / `--llm-max=<N>`：限制最多调用 LLM 的次数（不传则不限制）。

输出：

- `test/analysis_output_<seq>.json`：主输出文件，字段包括：
  - `input_seq`：输入的 `seq`。
  - `initial_taints`：初始污点集。
  - `result_set`：最终结果集（每项含 `seq/path/line/loc`）。
- `test/logs/info.log`/`debug.log`/`warning.log`：运行日志；LLM 模式下会出现 `queue_diffusion`、`llm_call` 等事件。
- `test/llm/prompts/prompt_<i>_seq_<seq>_id_<id>.txt`：第 i 次 LLM 调用的 prompt。
- `test/llm/responses/response_<i>_seq_<seq>_id_<id>.txt`：第 i 次 LLM 调用的原始返回。

### 2) `trace_edges.py`

用途：根据 `trace.log` 相邻 trace 分组，推断缺失的 `CALLS` 边并输出到 `trace_edges.csv`，用于弥补 `cpg_edges.csv` 中缺失的调用边。

用法：

- `python trace_edges.py`

输出：

- `trace_edges.csv`：补充的 `CALLS` 边（TSV：`start end type var`）。
- `trace_debug.json`：调试信息（每个 trace group 的匹配情况、候选调用等）。
- `trace_stats.txt`：统计信息（groups、missing_edges、existing_edges_in_cpg_edges）。

### 3) `if_extract.py`

用途：从给定源码位置（`/app/...:line`）提取该行对应的 `AST_IF_ELEM` 及其相关变量/调用信息，生成可读文本输出，供人工检查或给 `taint_trace.py` 使用。

用法：

- `python if_extract.py /app/phpbb/memberlist.php:98`

输出：

- `if_extract_output.txt`：文本输出（包含 input/if_elem_ids/变量/方法调用等）。

### 4) `taint_trace.py`

用途：离线（不依赖 LLM）地做一套基于 `trace_debug.json` + `if_extract_output.txt` 的 taint 扩散实验，输出每轮迭代的细节与最终污点集合。

用法：

- `python taint_trace.py`

前置条件：

- 先运行 `python trace_edges.py` 生成 `trace_debug.json`（以及可选 `trace_edges.csv`）。
- 先运行 `python if_extract.py <path:line>` 生成 `if_extract_output.txt`。

输出：

- `taint_debug.json`：每轮迭代的扩散细节（A/B 交替、added_by_* 等）。
- `taint_result.txt`：最终污点集合（按 `id type name` 输出）。

### 5) `if_elem_types.py`

用途：扫描 `nodes.csv` 中所有 `AST_IF_ELEM` 的后代节点，统计可能出现的“变量/表达式类型”，用于观察数据集覆盖情况。

用法：

- `python if_elem_types.py`

输出：

- `if_elem_types.txt`：收集到的类型列表（每行一个）。

## 常见输出文件速查

- `test/analysis_output_<seq>.json`：`analyze_if_line.py` 的主输出。
- `test/trace_index.json`：trace 索引缓存（将 `(path,line)` 映射到可能的 `seq/node_ids`）。
- `test/logs/*.log`：日志（INFO/DEBUG/WARNING/ERROR 分文件）。
- `test/llm/prompts/*.txt`、`test/llm/responses/*.txt`：LLM 调用输入/输出留档。
- `trace_edges.csv`：推断补充的 `CALLS` 边（可被 handler/LLM 筛选逻辑使用）。
- `trace_debug.json`：trace 分组与节点匹配调试信息（`taint_trace.py` 依赖）。
- `trace_stats.txt`：trace_edges 统计信息。
- `if_extract_output.txt`：if_extract 文本输出（`taint_trace.py` 依赖）。
- `taint_debug.json`、`taint_result.txt`：taint_trace 输出。
